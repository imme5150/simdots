<html>
  <head>
    <title>SimDots</title>
  </head>
  <body>
    <style>
      #boom {
        cursor:pointer;background-color:red;color:white;font-weight:bold;border:4px solid gray;position:absolute;bottom:15px;right:6.5%
      }
      #boom:hover {
        color:#000;
        border-color:#000;
        font-size:150%;
        right:5.5%;
      }
      #boom.active {
        border-color:white;
        font-size:100%;
        right:6.5%;
        cursor:not-allowed;
      }
      #boom.active.blink {
        color:red;
        background-color:#FFF;
      }
    </style>

    <div id="sidebar" style="float:right;width:18%">
      <select id="color">
        <option>black</option>
        <option>silver</option>
        <option>gray</option>
        <option>white</option>
        <option>maroon</option>
        <option>red</option>
        <option>purple</option>
        <option>fuchsia</option>
        <option>green</option>
        <option>lime</option>
        <option>orange</option>
        <option>yellow</option>
        <option>navy</option>
        <option>blue</option>
        <option>teal</option>
        <option>aqua</option>
      </select>
      &#x27A1;
      <select id="color-dest">
        <option>⦻</option>
        <option>black</option>
        <option>silver</option>
        <option>gray</option>
        <option>white</option>
        <option>maroon</option>
        <option>red</option>
        <option>purple</option>
        <option>fuchsia</option>
        <option>green</option>
        <option>lime</option>
        <option>orange</option>
        <option>yellow</option>
        <option>navy</option>
        <option>blue</option>
        <option>teal</option>
        <option>aqua</option>
      </select>
      <input id="persist" type="checkbox"/>⧂
      <br>
      <label for="freq">Amount:</label>
      <input id="freq" type="range" min="0" max="1" step="0.05">
      <br>
      <br>
      <span id="settings">
        <label for="size">Size:</label><br>
        <input id="size" type="range" value="3" min="1" max="40" step="0.5">
        <br>
        <br>
        <label for="speed">Speed:</label>
        <input id="speed" type="range" min="0" max="10" step="0.1" />
        <br>
        <label for="dir">Direction:</label>
        <input id="dir" type="range" min="0" max="6.283" step="0.1" />
        <br>
        <label for="spread">Spread:</label>
        <input id="spread" type="range" min="0" max="6.283" step="0.1" value="0" />
        <br>
        <label for="wiggle">Wiggle:</label>
        <input id="wiggle" type="range" min="0" max="10" step="0.5" value="0">
      </span>
      <br>
      <br>
      <div><label for="pause">Pause:</label> <input id="pause" type="checkbox"/></div>
      <br>
      <button id="save">Save</button>
      <br>
      <button id="boom">BOOM</button>
    </div>
    <canvas id="main" style="width:80%;height:100%;display:block"></canvas>
    <script>
      // TODO:
      // - Load state from JSON File
      // - add collision detection w/ walls - top, right, bottom, left?
      // - collision detection + rules
      // - direction as circle - https://bgrins.github.io/ui.anglepicker/
      // - hold mouse down keeps making dots - in amimate?
      // - speed variance?
      const canvas = document.getElementById("main");
      const behaviors = {};
      const resizeObserver = new ResizeObserver(() => {
        canvas.width = Math.round(canvas.clientWidth * devicePixelRatio);
        canvas.height = Math.round(canvas.clientHeight * devicePixelRatio);
      });
      resizeObserver.observe(canvas);
      function inBounds(dot, radius) {
        if (dot.x - radius > canvas.width || dot.x + radius < 0 || dot.y - radius > canvas.height || dot.y + radius < 0) {
          return false
        }
        return true
      }
      async function saveFile(data, fileName) {
        try {
          const fileHandle = await window.showSaveFilePicker({
            suggestedName: fileName
          });
          const writable = await fileHandle.createWritable();
          await writable.write(data);
          await writable.close();
        } catch (err) {
          console.error(err);
        }
      }
      document.getElementById("save").addEventListener('click', (e) => {
        const simplifiedDots = Object.fromEntries(
          Object.entries(dots).map(([color, dotSizes]) => ([
            color,
            Object.fromEntries(
              Object.entries(dotSizes).map(([radius, arrayOfDotObjects]) => ([
                radius,
                arrayOfDotObjects.map(dot => ([
                  Math.round(dot.x * 10) / 10,
                  Math.round(dot.y * 10) / 10
                ]))
              ])
            ))
          ]))
        );
        saveFile(JSON.stringify({
          dots: simplifiedDots,
          behaviors: behaviors,
          transform: transform
        }), "myDotFile.json");
      })

      document.getElementById("settings").addEventListener('change', (e) => {
        const key = e.target.getAttribute('id');
        behaviors[currentColor][key] = Number(e.target.value);
      });
      const transform = {};
      const transformSelector = document.getElementById("color-dest");
      const freqSelector = document.getElementById("freq");
      const persistSelector = document.getElementById("persist");
      const colorSelector = document.getElementById("color");
      function setDefaults(color, updateSelectors) {
        const needsDefaults = !behaviors[color];
        if (needsDefaults) behaviors[color] = {};
        const settings = {speed:5, dir:3.14, spread:0, wiggle:0, size:3};
        for (const [key, defaultValue] of Object.entries(settings)) {
          if (needsDefaults) behaviors[color][key] = defaultValue;
          if (updateSelectors) document.getElementById(key).value = behaviors[color][key];
        }
      }
      var currentColor;
      (setSelectedColor = function() {
        currentColor = colorSelector.value;
        setDefaults(currentColor, 'updateSelectors');
        if(!transform[currentColor]) {
          transform[currentColor] = {amount:0.5, color:currentColor, persist:false};
        }
        transformSelector.value = transform[currentColor].color;
        freqSelector.value = transform[currentColor].amount;
        persistSelector.checked = transform[currentColor].persist;
      })();
      colorSelector.addEventListener('change', setSelectedColor)

      transformSelector.addEventListener('change', (e) => {
        transform[currentColor].color = e.target.value;
      })
      freqSelector.addEventListener('change', (e) => {
        transform[currentColor].amount = e.target.value;
      })
      persistSelector.addEventListener('change', (e) => {
        transform[currentColor].persist = e.target.checked;
      })
      const boomButton = document.getElementById('boom');
      var boomStart = false;
      boomButton.addEventListener('click', (e) => {
        boomStart ||= new Date;
        e.target.classList.add('active');
      })

      const ctx = canvas.getContext("2d", {alpha:false});
      var drawing = false;
      const dots = {};

      canvas.addEventListener("mousedown", (event) => {
        drawing = true;
        const x = event.clientX - canvas.offsetLeft;
        const y = event.clientY - canvas.offsetTop;
        addDot(x,y)
      });
      canvas.addEventListener("mouseup", (event) => {
        drawing = false;
      });
      canvas.addEventListener("mouseenter", (event) => {
        drawing = (event.buttons & 1) == 1;
      });
      canvas.addEventListener("mouseleave", (event) => {
        drawing = false;
      });
      canvas.addEventListener('touchmove', (event) => {
        event.preventDefault();
        for (i = 0; i < event.touches.length; i++) {
          addDot(event.touches[i].clientX - canvas.offsetLeft, event.touches[i].clientY - canvas.offsetTop);
        }
      });
      canvas.addEventListener('mousemove', (event) => {
        if (!drawing) return
        addDot(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop);
      });
      function addDot(x,y) {
        const radius = Number(document.getElementById('size').value)
        dots[currentColor] = dots[currentColor] || {};
        dots[currentColor][radius] = dots[currentColor][radius] || [];
        dots[currentColor][radius].push({x:x, y:y, rnd:Math.random()});
      }
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.fillStyle = "lightblue";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const msSinceBoom = boomStart && new Date - boomStart;
        var targetWiggle = 0;
        var targetSpeed = 0;
        var targetSpread = 0;
        if (msSinceBoom) {
          if (msSinceBoom <= 3000) {
            targetWiggle = msSinceBoom / 300; // 0 -> 10
          } else {
            targetSpeed = 30;
            targetSpread = 6.283;
          }
        }
        for (const [color, dotSizes] of Object.entries(dots)) {
          for (const [radius, dotArray] of Object.entries(dotSizes)) {
            const speed = targetSpeed > behaviors[color].speed ? targetSpeed : behaviors[color].speed;
            const wiggle = targetWiggle > behaviors[color].wiggle ? targetWiggle : behaviors[color].wiggle;
            var iOut = 0;
            ctx.fillStyle = color;
            for (var i = 0; i < dotArray.length; i++) {
              const dot = dotArray[i];
              // Update dot position
              const paused = !boomStart && document.getElementById('pause').checked;
              if (!paused) {
                const spread = targetSpread > behaviors[color].spread ? targetSpread : behaviors[color].spread;
                const angle = behaviors[color].dir + dot.rnd * spread - spread / 2;
                const dx = Math.cos(angle) * speed;
                const dy = Math.sin(angle) * speed;
                dot.x += dx + Math.random() * wiggle - wiggle / 2;
                dot.y += dy + Math.random() * wiggle - wiggle / 2;
              }
              if (inBounds(dot, radius)) {
                if (!paused && transform[color] && transform[color].color != color && Math.random() <= transform[color].amount / 30) {
                  const targetColor = transform[color].color;
                  if (targetColor.length > 1) {
                    if (!dots[targetColor]) {
                      dots[targetColor] = {};
                      setDefaults(targetColor, false);
                    }
                    dots[targetColor][radius] = dots[targetColor][radius] || []
                    dots[targetColor][radius].push(dot);
                    if (transform[color].persist) { // keep original dot too
                      var newDot = Object.assign({}, dot);
                      newDot.rnd = Math.random(); // new random number
                      dotArray[iOut++] = newDot;
                    }
                  }
                } else {
                  dotArray[iOut++] = dot;

                  // Draw dot
                  ctx.beginPath();
                  ctx.arc(dot.x, dot.y, radius, 0, 2 * Math.PI);
                  ctx.fill();
                }
              }
            }
            dotArray.length = iOut;
          }
          if (boomStart) {
            if (Math.floor((new Date - boomStart) / 1000) % 2) {
              boomButton.classList.add('blink');
            } else {
              boomButton.classList.remove('blink');
            }
            if (Object.values(dots).reduce((sum, a) => sum + a.length, 0) == 0) {
              boomStart = false;
              boomButton.classList.remove('blink', 'active');
            }
          }
        }
        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
