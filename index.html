<html>
  <head>
    <title>SimDots</title>
  </head>
  <body>
    <style>
    </style>

    <div id="sidebar" style="float:right;width:18%">
      <select id="color">
        <option>black</option>
        <option>silver</option>
        <option>gray</option>
        <option>white</option>
        <option>maroon</option>
        <option>red</option>
        <option>purple</option>
        <option>fuchsia</option>
        <option>green</option>
        <option>lime</option>
        <option>olive</option>
        <option>yellow</option>
        <option>navy</option>
        <option>blue</option>
        <option>teal</option>
        <option>aqua</option>
      </select>
      <br>
      <label for="speed">Speed:</label>
      <input id="speed" type="range" min="0" max="10" step="0.1" />
      <br>
      <label for="dir">Direction:</label>
      <input id="dir" type="range" min="0" max="6.283" step="0.1" />
      <br>
      <label for="wiggle">Wiggle:</label>
      <input id="wiggle" type="range" min="0" max="10" step="0.5" value="0">
      <br>
      <br>
      <div>Pause: <input id="pause" type="checkbox"/></div>
      <label for="freq">Amount:</label>
      <input id="freq" type="range" min="0" max="1" step="0.05">
    </div>
    <canvas id="main" style="width:80%;height:100%;display:block"></canvas>
    <script>
      // TODO:
      // - save preference by color
      // - ability to draw in color from dropdown
      // - collision detection + rules
      // - direction as circle
      // - hold mouse down keeps making dots - in amimate?
      // - Direction * speed variance? store rnd value on each dot - spread is good - needs to stay centered on direction
      const radius = 3;
      const canvas = document.getElementById("main");
      const resizeObserver = new ResizeObserver(() => {
        canvas.width = Math.round(canvas.clientWidth * devicePixelRatio);
        canvas.height = Math.round(canvas.clientHeight * devicePixelRatio);
      });
      resizeObserver.observe(canvas);
      function inBounds(dot) {
        if (dot.x + radius > canvas.width || dot.x - radius < 0 || dot.y + radius > canvas.height || dot.y - radius < 0) {
          return false
        }
        return true
      }

      const ctx = canvas.getContext("2d", {alpha:false});
      var drawing = false;
      const dots = [];
      const cdots = [];

      canvas.addEventListener("mousedown", (event) => {
        drawing = true;
        const x = event.clientX - canvas.offsetLeft;
        const y = event.clientY - canvas.offsetTop;
        addDot(x,y)
      });
      canvas.addEventListener("mouseup", (event) => {
        drawing = false;
      });
      canvas.addEventListener("mouseenter", (event) => {
        drawing = (event.buttons & 1) == 1;
      });
      canvas.addEventListener("mouseleave", (event) => {
        drawing = false;
      });
      canvas.addEventListener("mousemove", (event) => {
        if (!drawing) return
        const x = event.clientX - canvas.offsetLeft;
        const y = event.clientY - canvas.offsetTop;
        addDot(x,y)
      });
      function addDot(x,y) {
        cdots.push({x:x, y:y});
      }
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.fillStyle = "lightblue";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const freq = Number(document.getElementById('freq').value)
        if (!document.getElementById('pause').checked) {
          for (let cdot of cdots) {
            if (Math.random() <= freq / 30) {
              dots.push({x:cdot.x,y:cdot.y})
            }
          }
        }
        ctx.fillStyle = document.getElementById('color').value;
        var iOut = 0;
        const speed = Number(document.getElementById('speed').value)
        const angle = Number(document.getElementById('dir').value)
        const wiggle = Number(document.getElementById('wiggle').value)
        for (var i = 0; i < dots.length; i++) {
          const dot = dots[i];
          // Update dot position
          if (!document.getElementById('pause').checked) {
           const dx = Math.cos(angle) * speed;
           const dy = Math.sin(angle) * speed;
           dot.x += dx + Math.random() * wiggle - wiggle / 2;
           dot.y += dy + Math.random() * wiggle - wiggle / 2;
          }
          if (inBounds(dot)) {
            dots[iOut++] = dot;

            // Draw dot
            ctx.beginPath();
            ctx.arc(dot.x, dot.y, radius, 0, 2 * Math.PI);
            ctx.fill();
          }
        }
        dots.length = iOut;
        ctx.fillStyle = "brown";
        for (let dot of cdots) {
          // Draw dot
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, radius, 0, 2 * Math.PI);
          ctx.fill();
        }

        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
